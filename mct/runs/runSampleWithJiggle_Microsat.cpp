/* MCT - Markov Chains on Trees.


   Copyright (C) 2011, 2012 Jennifer Harow

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

/*! \file
\brief Sample some mct::MultiLociMicrosat objects using a 
mct::MultiLociMicrosatSampler and 'true' parameters and then 
look at these objects in the context of samples of reps generated
by other sets of parameters.  
 
mct::MultiLociMicrosat objects represent multiple loci of microsate data
summarised as microsat repeats data.  
  
The aim here is to use a particular set of parameter values and to get a small 
number of mct::MultiLociMicrosat reps and then look at summary statistics 
from these against the distribution of summary statistics for
large samples from other sets of parameter values - these other sets 
of parameter values are what I refer to as the 'jiggles' - a little bit
away from the true values.    

Further analysis (eg with mrs histograms) can place summary stats for the small
number of samples from the 'true' distribution against the shape of the
densities (estimated with the large samples) of the same summary stats
generated by simuling objects with for different sets of parameters.

This was kind of the precursor to AHABC, but here I use
mean and covar of microsat repeats as the summary stat.

*/

#include "config.h"

#include "multi_loci_microsat_sampler.hpp"
#include "multi_loci_microsat_set.hpp"
#include "multi_loci_microsat.hpp"

#include "model_set_config_builder.hpp"
#include "modelset.hpp"

#include "descriptive_stats.hpp"
#include "summary_statistic_set.hpp"

#include "parameter_particle.hpp"

#include "prng.hpp"
#include "prng_gsl.hpp"

#include "utilities.hpp"

#include "make_run_pops.hpp"

#include <mscplusplus/population_structure.hpp>

#include <boost/lambda/bind.hpp>
#include <boost/lambda/lambda.hpp>

#include <boost/shared_ptr.hpp>


#include <iostream>
#include <sstream>
#include <vector>
#include <set>

#define TESTING

#define FILEOUTPUT // define for fileoutput

#ifdef TESTING
	#ifdef FILEOUTPUT
		#undef FILEOUTPUT
	#endif
#endif

using namespace std;
using namespace mct;
using namespace aabc;

void runSample_Microsat();

void runSub(const boost::shared_ptr< const hudson_ms::PopulationStructure > pop,
	const std::string& filenamepop,
	const std::string& filenamestart,
	double theta, double growth, 
	size_t nloci, size_t n_examples, size_t nsites, 
	const vector < size_t>& nloci_nsites,
	size_t toPick) ;
	
void pickSome(size_t toPick, size_t n_examples,
				const std::vector < boost::shared_ptr < SummaryStatisticSet > >& ss_sets,
				const std::vector < std::string >& filenametypes);


int main()
{
	runSample_Microsat();
	
	
	return 0;
	
}

	

void runSample_Microsat()
{
	try {
		
		int myPid = getpid();
		std::cout << "Range of microsat stats for MultiLociMicrosatSampler sampler" << std::endl;
		std::cout << "This process id is " << myPid << std::endl;
		
		// number of reps to generate for each combination of possible parameter value of interest
		size_t n_examples = 100000;
		#ifdef TESTING
			if (n_examples > 1000) n_examples = 1000;
		#endif
		
		// loci in each multi-loci microsat
		size_t nloci = 25; 
		
		size_t nsites = 1; // number of sites in each locus 
		
		/*microsats have the possibility of having different sites per locus
		 * so summarise here that we have all loci each with nsites */
		vector < size_t> nloci_nsites(nloci, nsites);
		
		size_t Nzero = 1000000; // effective popn size (per sub-pop)
		
		double unit = 100000.0; // 10^5
		// unit just helps with specifying mu_per_site
		// what is given here is mu/site * unit
		double mymus[] = {5.0, 3.0, 7.0};
		// 'real' mu/site is mu_per_site divided by unit
		
		/* transform mus to a colleciton of theta PER SITE = 4N0(mu/site) */
		std::vector <double> mus (mymus, mymus + sizeof(mymus) / sizeof(double) );
		std::vector <double> thetas(mus.size());
		
		using namespace boost::lambda;
		transform(mus.begin(), mus.end(), thetas.begin(), _1*4*Nzero/unit);
		
		//growth rates
		double mygrowths[] = {20.0, 10, 30};
		std::vector <double> growths (mygrowths, mygrowths + sizeof(mygrowths) / sizeof(double) );
		
		/* in these arrays, the first one is going to be the 'true' one and
		 * the others are 'jiggles' either side.*/
		
		//population structure
		boost::shared_ptr< hudson_ms::PopulationStructure > pop = makePopIslandSmall(Nzero);
	
		std::string filenamepop = "PopSmall"; // alter this one
		
		{
			// base run - just uses the first values in each set
			cout << "\nBase run" << endl;
		
			double theta = thetas.front();
		
			double growth = growths.front();
				
			cout << "\nSimple means and covariances" << endl;
			
			std::string filenamestart = "MicrosatJigglesBase";
			
			size_t toPick = 10;
			
			runSub(pop, filenamepop, filenamestart,
					theta, growth, 
					nloci, n_examples, nsites, nloci_nsites,
					toPick);
			
			
			
		}
		
		// jiggles
		cout << "\nPopulations from jiggled parameters" << endl;
		
		/* loop through the combinations of theta and growth */
				
		for (std::vector < double>::iterator theta_it = thetas.begin(); 
				theta_it < thetas.end();
				++ theta_it) {
					
			for (std::vector < double>::iterator growth_it = growths.begin(); 
				growth_it < growths.end();
				++ growth_it) {
					
				/* don't do for the first pair, but do every other combination,
				 * ie including true theta+false growth and false theta+true growth */
				if ( !((theta_it == thetas.begin()) && (growth_it == growths.begin())) ) {
			
					double theta = *theta_it;
					double growth = *growth_it;
					
					std::string filenamestart = "MicrosatJiggles";
			
					size_t toPick = 0;
					
					runSub(pop, filenamepop, filenamestart,
							theta, growth, 
							nloci, n_examples, nsites, nloci_nsites,
							toPick);
			
				}	
			}
		}
		
	}
	catch (std::exception& e) {
	
		std::cout << "Error:\n" + std::string(e.what()) << std::endl;
	}
}


void runSub(const boost::shared_ptr< const hudson_ms::PopulationStructure > pop,
	const std::string& filenamepop,
	const std::string& filenamestart,
	double theta, double growth, 
	size_t nloci, size_t n_examples, size_t nsites, 
	const vector < size_t>& nloci_nsites,
	size_t toPick) 
{
		
	cout << "theta " << theta << " growth " << growth << endl;
	
	std::string popStr = pop->toString();
	std::cout << "Pop structure is " << popStr << endl;
	
	int seed = 2345;
	boost::shared_ptr < PRNGen > r ( new PRNGenGSL(seed) );
	
	/*
	 * use this prng to spawn others for sampler and models.
	 * This ensures that results are independent of how
	 * internals of either work, and we can increase samples
	 * and models and first results will be the same as before
	 * the increase
	 * */
	boost::shared_ptr < PRNGen > r_sampler = r->spawnAnother();

	boost::shared_ptr < PRNGen > r_models = r->spawnAnother();
		
	std::ostringstream stm;
	stm << "_ns_" << pop->totalNsam() << "_nl_" << nloci << "_n_" << n_examples;
	stm.precision(3);
	stm <<   fixed;
	stm << "_th_" << theta;
	stm << "_g_" << growth << ".txt";
	
	std::string filenametype1 = "Means";
	std::string filenametype2 = "Covar";
	std::string filenametype3 = "DeltaMu";
	std::string filenametype4 = "Fsts";

	std::string filename1 = filenamestart + filenamepop + filenametype1 + stm.str();
	std::string filename2 = filenamestart + filenamepop + filenametype2 + stm.str();
	std::string filename3 = filenamestart + filenamepop + filenametype3 + stm.str();
	std::string filename4 = filenamestart + filenamepop + filenametype4 + stm.str();
	
	std::string path("../output/");

	filename1 = path + filename1;
	filename2 = path + filename2;
	filename3 = path + filename3;
	filename4 = path + filename4;
	
	cout << "Making sampler" << endl;
						
	/*use a ModelSetConfigBuilder to build the model data */
	mct::ModelSetConfigBuilder configBuilder;
	configBuilder.addModelConfig("SMM", nsites); // SMM model
	// create our models, one for each site, with default thetas
	boost::shared_ptr < mct::ModelSet > 
		mset_ptr	( 
			new mct::ModelSet(configBuilder.getModelSetConfigs()
									, r_models)
					);
	
	/* Make a multilocus model set with nloci copies of the same modelset*/
	boost::shared_ptr < mct::MultiLociModelSetSet > 
			models_ptr	( 
				new mct::MultiLociModelSetSet(mset_ptr, nloci) );

	// configure a sampler with modelset
	boost::shared_ptr < MultiLociMicrosatSampler > 
				sampler ( new MultiLociMicrosatSampler(models_ptr, r_sampler) );
	
	double realvalues[] = {theta,growth}; 
	
	boost::shared_ptr < ParameterParticle > p( new ParameterParticle(realvalues, 2) );

	cout << "Sampling" << endl;

	// get the samples from the sampler
	boost::shared_ptr < mct::MultiLociMicrosatSet > 
		refset_ptr = sampler->sample(n_examples,
		pop, nloci_nsites, p);
	
	
	std::vector < boost::shared_ptr < SummaryStatisticSet > > ss_sets;
	std::vector < std::string > filenames;
	std::vector < std::string > filenametypes;
	
	/* and get the summary statistics for this set */
	try {
		ss_sets.push_back(	refset_ptr->getAverageRepeats() );
		filenames.push_back(filename1);
		filenametypes.push_back(filenametype1);
	}
	catch (std::runtime_error& re) {
		cout << "Runtime error:\n" << re.what() << endl;
	}
	try {
		ss_sets.push_back(	refset_ptr->getCovariances() );
		filenames.push_back(filename2);
		filenametypes.push_back(filenametype2);
	}
	catch (std::runtime_error& re) {
		cout << "Runtime error:\n" << re.what() << endl;
	}
	
	/* IMPORTANT - remember that my implementations of these statistics 
	 * are just trying to replicate what Arlequin produces - these
	 * might not be the best statistics to use at all.*/
	
	try {
		ss_sets.push_back(	refset_ptr->getDistanceDeltaMuSqBetweenPop() );
		filenames.push_back(filename3);
		filenametypes.push_back(filenametype3);
	}
	catch (std::runtime_error& re) {
		cout << "Runtime error:\n" << re.what() << endl;
		
	}
	
	try {
		ss_sets.push_back(	refset_ptr->getBetweenPopFst() );
		filenames.push_back(filename4);
		filenametypes.push_back(filenametype4);
	}
	catch (std::runtime_error& re) {
		cout << "Runtime error:\n" << re.what() << endl;
	}
	
	assert( ss_sets.size() == filenames.size() );
	
	#ifdef FILEOUTPUT
		cout << "Sending output to files" << endl;

		for (size_t i = 0; i < filenames.size(); ++i) {
			mct_utilities::outputToFile(popStr, filenames[i], false); // overwrite
			ss_sets[i]->outputToFile(filenames[i], true); // append
		}
	#endif
	
	cout << "\nGet the descriptive statistics and send to standard output: " << endl;
	
	std::vector < std::string >::iterator it = filenametypes.begin();
	for (std::vector < boost::shared_ptr < SummaryStatisticSet > >::iterator sit = ss_sets.begin();
		sit < ss_sets.end();
		++sit, ++it) {
			
		if (!(*sit)->empty() ) {
			cout << "\nDescriptive statistics for " << (*it) << endl;
			for ( size_t index = 0; index < (*sit)->at(0)->size(); ++index ) {
				cout << "\tAt index " << index << "\t";
				DescriptiveStats ds((*sit), index);
				std::cout << (ds.toString()) << std::endl;
			}
		}
	}
	
	if (toPick) pickSome(toPick, n_examples, ss_sets, filenametypes);
	
}

void pickSome(size_t toPick, size_t n_examples,
				const std::vector < boost::shared_ptr < SummaryStatisticSet > >& ss_sets,
				const std::vector < std::string >& filenametypes)
{
	set < size_t > picks;
	
	while (picks.size() < toPick) {
		picks.insert ( (rand() % n_examples) );
	}
	
	cout << "\nPicking out " << toPick << " reps at random:" << endl;
			
	for (set < size_t >::iterator it = picks.begin();
			it != picks.end();
			++it) {
	
		size_t pick = *it;
		
		cout << "\nSelected index " << pick << ".  Stats are:" << endl;
	
		std::vector < std::string >::const_iterator it = filenametypes.begin();
		for (std::vector < boost::shared_ptr < SummaryStatisticSet > >::const_iterator sit = ss_sets.begin();
			sit < ss_sets.end();
			++sit, ++it) {
				
			cout << (*it) << endl;
			cout << ((*sit)->at(pick))->toString();
		}
	}
}	
