/* MCT - Markov Chains on Trees.


   Copyright (C) 2011, 2012 Jennifer Harow

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

/*! \file
\brief Sample mct::MultiLociMicrosat objects using a 
mct::MultiLociMicrosatSampler.
 
mct::MultiLociMicrosat objects represent multiple loci of microsat data
summarised as microsat repeats data.  
  
The aim here is to use some particular parameter values and to get a large 
number of mct::MultiLociMicrosat reps for any particular
set or combination of them (ie consider these a sample from the population
of possible mct::MultiLociMicrosat objects given those values), and get
the summary statistics for the reps.  The summary statistics can be
further analysed to give an idea of the shape of their distribution.

In this program I use a population consisting of a number of subpopulations
and the summary statistics compare pairs of subpopulations within
the total populations.

To get the mct::MultiLociMicrosat objects I use the mct::MultiLociMicrosatSampler,
which uses our own mct models (and args generated by my mscplusplus
replication of the ms routine - we would not be able to use libsequence
to generate the arg because that cannot do populations of subpopulations).

*/

#include "config.h"

#include "multi_loci_microsat_sampler.hpp"
#include "multi_loci_microsat_set.hpp"
#include "multi_loci_microsat.hpp"

#include "model_set_config_builder.hpp"
#include "modelset.hpp"

#include "descriptive_stats.hpp"
#include "summary_statistic_set.hpp"

#include "parameter_particle.hpp"

#include "prng.hpp"
#include "prng_gsl.hpp"

#include "utilities.hpp"

#include "make_run_pops.hpp"

#include <mscplusplus/population_structure.hpp>

#include <boost/lambda/bind.hpp>
#include <boost/lambda/lambda.hpp>

#include <boost/shared_ptr.hpp>


#include <iostream>
#include <sstream>
#include <vector>
#include <stack>

//#define FILEOUTPUT // define for fileoutput

using namespace std;
using namespace mct;
using namespace aabc;

void runSample_Microsat();

void runSub(const boost::shared_ptr< const hudson_ms::PopulationStructure > pop,
	const std::string& filenamepop,
	double theta, double growth, 
	size_t nloci, size_t n_examples, size_t _nsites, 
	const vector < size_t>& nsites);

std::string makeFilename(	const std::string& path,
							const std::string& filenamestart,
							const std::string& filenamepop,
							const std::string& filenametype,
							const std::string& filenamedetails);

int main()
{
	runSample_Microsat();
	
	
	return 0;
	
}

	

void runSample_Microsat()
{
	try {
		
		int myPid = getpid();
		std::cout << "Range of microsat stats for MultiLociMicrosatSampler sampler" << std::endl;
		std::cout << "This process id is " << myPid << std::endl;
		
		// loci in each multi-loci microsat
		size_t nloci = 25; 
		
		size_t nsites = 1; // number of sites in each locus 
		
		//vector of nloci copies of nsites
		std::vector < size_t > nloci_nsites(nloci, nsites);
			
		size_t Nzero = 1000000; // effective popn size (per sub-pop)
		
		double unit = 100000.0; // 10^5
		// unit just helps with specifying mu_per_site
		// what is given here is mu_per_site * unit
		double mymus[] = {1.0, 2.5, 5.0, 7.5, 10.0};
		// 'real' mu_per_site is above divided by unit
		
		/* transform mus to a colleciton of theta PER SITE = 4N0(mu/site) */
		std::vector <double> mus (mymus, mymus + sizeof(mymus) / sizeof(double) );
		std::vector <double> thetas(mus.size());
		
		using namespace boost::lambda;
		transform(mus.begin(), mus.end(), thetas.begin(), _1*4*Nzero/unit);
		
		//growth rates
		double mygrowths[] = {10, 20.0,30.0, 50, 80};
		std::vector <double> growths (mygrowths, mygrowths + sizeof(mygrowths) / sizeof(double) );
		
		// number of reps to generate for each combination of possible parameter value of interest
		//size_t n_examples = 100000;
		size_t n_examples = 1000;
		
		// loop through combinations of nloci, theta and growth ...
		for (std::vector < double>::iterator theta_it = thetas.begin(); 
				theta_it < thetas.end();
				++ theta_it) {
					
			for (std::vector < double>::iterator growth_it = growths.begin(); 
				growth_it < growths.end();
				++ growth_it) {
					
				double theta = *theta_it;
				double growth = *growth_it;
				
				/* A population structure that includes 3 subpopulations.
				 * See the make_run_pops subroutines for details. */
				boost::shared_ptr< hudson_ms::PopulationStructure > 
								pop = makePopIslandBalLessComm(Nzero);
			
				
				// describe the population structure I'll be using in the inner loop
				cout << "\n\n3 balanced populations" << endl;
				
				std::string filenamepop = "PopBalLessComm"; // alter this one
				
				runSub( pop,
					filenamepop,
					theta, growth, 
					nloci, n_examples, nsites, 
					nloci_nsites);
								
			}
		}
		
	}
	catch (std::exception& e) {
	
		std::cout << "Error:\n" + std::string(e.what()) << std::endl;
	}
}

void runSub(const boost::shared_ptr< const hudson_ms::PopulationStructure > pop,
	const std::string& filenamepop,
	double theta, double growth, 
	size_t nloci, size_t n_examples, size_t nsites, 
	const vector < size_t>& nloci_nsites)
{
	int seed = 2345;
	boost::shared_ptr < PRNGen > r ( new PRNGenGSL(seed) );
	
	/*
	 * use this prng to spawn others for sampler and models.
	 * This ensures that results are independent of how
	 * internals of either work, and we can increase samples
	 * and models and first results will be the same as before
	 * the increase
	 * */
	boost::shared_ptr < PRNGen > r_sampler = r->spawnAnother();

	boost::shared_ptr < PRNGen > r_models = r->spawnAnother();
	
	cout << "theta " << theta << " growth " << growth << endl;
	
	// Get the pop to give description of itself */
	std::string popStr = pop->toString();
	std::cout << "Pop structure is " << popStr << endl;
	
	// create a string that summarises all our different values, to label output
	std::ostringstream stm;
	stm << "_ns_" << pop->totalNsam() << "_nl_" << nloci << "_n_" << n_examples;
	stm.precision(3);
	stm <<   fixed;
	stm << "_th_" << theta;
	stm << "_g_" << growth << ".txt";
	
	std::string filenamedetails = stm.str();
	
	// long winded process to build up some filenames
	std::string filenamestart = "MicrosatResults";
	
	std::string filenametype1 = "Means";
	std::string filenametype2 = "Covar";
	
	std::string filenametype3 = "DeltaMu";
	std::string filenametype4 = "Fsts";
	
	// specifiy a path - that directory had better exist or
	// there will be an error outputting the file. 
	std::string path("../output/");

	std::string filename1 = makeFilename(path, filenamestart, filenamepop,
							filenametype1, filenamedetails);
	std::string filename2 = makeFilename(path, filenamestart, filenamepop,
							filenametype2, filenamedetails);
	std::string filename3 = makeFilename(path, filenamestart, filenamepop,
							filenametype3, filenamedetails);
	std::string filename4 = makeFilename(path, filenamestart, filenamepop,
							filenametype4, filenamedetails);
	
	
	cout << "\nMaking sampler" << endl;
	
	//use a ModelSetConfigBuilder to build the model data 
	mct::ModelSetConfigBuilder configBuilder;
	configBuilder.addModelConfig("SMM", nsites); // SMM model
	// create our models, one for each site, with default thetas
	boost::shared_ptr < mct::ModelSet > 
		mset_ptr	( 
			new mct::ModelSet(configBuilder.getModelSetConfigs()
									, r_models)
					);
	
	/* Make a multilocus model set with nloci copies of the same modelset*/
	boost::shared_ptr < mct::MultiLociModelSetSet > 
	models_ptr	( 
		new mct::MultiLociModelSetSet(mset_ptr, nloci) );

	
	/* Make the sampler for this inner loop: the sampler
	 * will create MultiLociMicrosat objects from which
	 * we get the statistics.  The sampler
	 * is configured with the models and a prng  */
	boost::shared_ptr < MultiLociMicrosatSampler > 
				sampler ( new MultiLociMicrosatSampler(models_ptr, r_sampler) );
	
	/* make a parameter particle with the theta and growth values
	 * being used for this inner loop.  */
	double realvalues[] = {theta,growth}; 
	boost::shared_ptr < ParameterParticle > p( new ParameterParticle(realvalues, 2) );

	cout << "\nSampling" << endl;

	/* Make a set of reps as a sample of mct::MultiLociMicrosat
	 * that can be generated using these parameter values.*/
	boost::shared_ptr < mct::MultiLociMicrosatSet > 
		refset_ptr = sampler->sample(n_examples,
		pop, nloci_nsites, p);
	
	std::vector < boost::shared_ptr < SummaryStatisticSet > > ss_sets;
	std::vector < std::string > filenames;
	std::vector < std::string > filenametypes;
	
	/*The summary statistics for microsats is just a (arbitrarily chosen)
	 * subset of the (limited) set of statistics I implemented for
	 * microsats.  It is probably better to get the individual
	 * sets of statistics directly from the set of mct::MultiLociMicrosat.*/
	try {
		ss_sets.push_back(	refset_ptr->getAverageRepeats() );
		filenames.push_back(filename1);
		filenametypes.push_back(filenametype1);
	}
	catch (std::runtime_error& re) {
		cout << "Runtime error:\n" << re.what() << endl;
	}
	try {
		ss_sets.push_back(	refset_ptr->getCovariances() );
		filenames.push_back(filename2);
		filenametypes.push_back(filenametype2);
	}
	catch (std::runtime_error& re) {
		cout << "Runtime error:\n" << re.what() << endl;
	}
	
	/* IMPORTANT - remember that my implementations of these statistics 
	 * are just trying to replicate what Arlequin produces - these
	 * might not be the best statistics to use at all.*/
	
	try {
		ss_sets.push_back(	refset_ptr->getDistanceDeltaMuSqBetweenPop() );
		filenames.push_back(filename3);
		filenametypes.push_back(filenametype3);
	}
	catch (std::runtime_error& re) {
		cout << "Runtime error:\n" << re.what() << endl;
		
	}
	try {
		ss_sets.push_back(	refset_ptr->getBetweenPopFst() );
		filenames.push_back(filename4);
		filenametypes.push_back(filenametype4);
	}
	catch (std::runtime_error& re) {
		cout << "Runtime error:\n" << re.what() << endl;
		
	}
	
	
	assert( ss_sets.size() == filenames.size() );
	
	#ifdef FILEOUTPUT
		cout << "Sending output to files" << endl;
		
		for (size_t i = 0; i < filenames.size(); ++i) {
			mct_utilities::outputToFile(popStr, filenames[i], false); // overwrite
			ss_sets[i]->outputToFile(filenames[i], true); // append
		}
	#endif
	
	cout << "\nGet the descriptive statistics and send to standard output: " << endl;
	
	std::vector < std::string >::iterator it = filenametypes.begin();
	for (std::vector < boost::shared_ptr < SummaryStatisticSet > >::iterator sit = ss_sets.begin();
		sit < ss_sets.end();
		++sit, ++it) {
			
		if (!(*sit)->empty() ) {
			cout << "\nDescriptive statistics for " << (*it) << endl;
			for ( size_t index = 0; index < (*sit)->at(0)->size(); ++index ) {
				cout << "\tAt index " << index << "\t";
				DescriptiveStats ds((*sit), index);
				std::cout << (ds.toString()) << std::endl;
			}
		}
	}
	std::cout << std::endl;
}

std::string makeFilename(	const std::string& path,
							const std::string& filenamestart,
							const std::string& filenamepop,
							const std::string& filenametype,
							const std::string& filenamedetails)
{
	return path + filenamestart + filenamepop + filenametype + filenamedetails + std::string(".txt");
}

