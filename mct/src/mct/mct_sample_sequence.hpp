/* MCT - Markov Chains on Trees.

   Copyright (C) 2011 Jenny Harlow

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

/*! \file     
\brief MCTSampleSequence declarations.
*/

#ifndef _INC_MCTSAMPLESEQUENCE_H
#define _INC_MCTSAMPLESEQUENCE_H

#include "ind_site_sequence.hpp"
#include "site_seq.hpp"
#include "mct_locus_map.hpp"

#include <Sequence/PolySites.hpp>

#include <boost/smart_ptr.hpp>

#include <vector>
#include <string>


namespace mct {
	
	/** @brief A class for sequence data generated by MCT for a 
	 for a sample of individuals.
	 
	 The sequence is assumed to cover one locus.
	 
	 Information for each individual is available in an
	 IndividualSiteSequence structure.  
	 
	 A MCTSampleSequence is configured with a MCTLocusMap 
	 to describe what kind of 
	 data is stored at each site in the locus.	
	  
	 */
	 

	class MCTSampleSequence {
		public:
		
			/*! \brief Constructor.
			
			\param seqs A container of individual site sequence data, one for
			each individual in the sample.
			\param lm A map of the layout of the locus, which tells
			the sequence what kind of data is stored at each site.
			*/
			MCTSampleSequence(
					const std::vector < IndividualSiteSequence >& seqs,
					const boost::shared_ptr < MCTLocusMap >& lm);
			
			/*! \brief Constructor.
			
			\param pls A container of population indices, one for
			each individual in the sample.
			\param ss A container of site sequence data, 
			one for each individual in the sample.
			\param lm A map of the layout of the locus, which tells
			the sequence what kind of data is stored at each site.
			*/
			MCTSampleSequence(
					const std::vector < size_t >& pls,
					const std::vector < site_seq >& ss,
					const boost::shared_ptr < MCTLocusMap >& lm);
			
			virtual ~MCTSampleSequence();
			
			/*! \brief Get an indexed IndividualSiteSequence in the sample.
			
			This method returns IndividualSiteSequence, i.e structure 
			containing population and site_seq data.
			
			\param seq_index The index of the IndividualSiteSequence to get.
			\return A copy of the IndividualSiteSequence at \a index. */
			IndividualSiteSequence getIndividualSequenceAt(
										const size_t seq_index) const;
			
			/*! \brief Get the number of sequences in the sample.*/
			size_t nsam() const;
			
			/*! \brief Get a string representation of this.
			 
			 The string includes population labels.*/
			virtual std::string toString() const;
			
			/*! \brief Get a string representation of the sample
			in Phylip format.  
			
			Sections of the sequences to which nucleotide models 
			are applied are decoded to nucleotide format, sections
			to which microsatellite models are applied are decoded
			to microsatellite repeat format.
			* 
			One single string is returned, with new line characters
			delimiting sequences for different individual in the sample.
			
			\return A string of formatted decoded sequences.*/
			virtual std::string stringPhylipFormat() const;
			
			
			/*! \brief Return a pointer to the sequence 
			in nucleotide-coded polysite table format.
			 
			This method will throw a std::domain_error exception if the coded
			sequence contains any non-DNA characters or 
			is not aligned (ie has unequal lengths in the samples).
			
			\internal
			It would be nice to be able to make our Sequence::PolySites
			representation straight from our raw sequence, ie not
			recoded to nucleotides, but Kevin's routines for turning
			data into a Sequence::PolySites will only recognise states
			0,1, or the nucleotides (or n or N for missing). We could
			write our own routine for getting the polymorphic states from
			our sequences, but we still have potential problems if we 
			want to use Kevin's routines because he wants strings of
			polymorphic site states where each character is a state
			and we cannot guarantee that a raw sequence state will
			(one int) always be a single character - so we could do
			our own recoding to 0's and 1's but then we lose all the
			actual site state stuff and have problems about coding
			more than 2 states and in any case would probably lose much 
			of the hoped-for efficiency benefits 
			of trying to avoid the recoding as nucleotides?  It may be
			worth thinking about this more if we use the mct models more.
			
			\return A pointer to the Sequence::PolySites representation
			of the sequence.
			\pre The sequence is aligned and only contains
			DNA data.	*/
			boost::shared_ptr < Sequence::PolySites > 
					polyNucTableFormatPtr() const;
			
			/*! \brief Return the sequence in nucleotide-coded
			polysite table format.
			 
			This method will throw a std::domain_error exception if the coded
			sequence contains any non-DNA characters or 
			if not aligned (ie has unequal lengths in the samples).
			
			\return The Sequence::PolySites representation of the 
			sequence.
			\pre The sequence is aligned and only contains
			DNA data.	*/
			virtual Sequence::PolySites polyNucTableFormat() const;
			
			/*! \brief Return the sequence as a collection
			of microsatellite repeats data.
			 
			This method will throw a std::domain_error if the coded
			sequence contains any non-microsat data.
			
			\return A collection of 
			\link mct::site_seq site_seqs\endlink 
			representations of the sequence data.
			\pre The sequence only contains microsat data.	*/
			virtual std::vector < site_seq > 
								microsatRepeatsFormat() const;
			
			/*! \brief Return the sequence as a collection
			of integer coded data.
			
			This method makes no checks or assumptions about the
			type of the data; it just returns the 'raw' site_seqs. 
						 
			\return A collection of 
			\link mct::site_seq site_seqs\endlink of the sequence data.*/
			virtual std::vector < site_seq > siteSeqFormat() const;
						
		protected:
		
			typedef std::vector< site_seq > samples;
			
			typedef samples::const_iterator const_iterator;
			
			static std::string nucleotides;
		
			MCTSampleSequence();
			
			explicit MCTSampleSequence(const MCTSampleSequence& other);
			
			MCTSampleSequence& operator=(MCTSampleSequence tmp);
						
			std::vector < std::string >& codeSeqs(
						std::vector < std::string >& strs) const;
			
			std::vector < std::string>& dnaCodeToString(
				std::vector < std::string>& strs, 
				const size_t from, 
				const size_t to) const;
			
			std::vector < std::string >& rawToString(
				std::vector < std::string>& strs) const;
				
			std::vector < std::string>& microsatCodeToString(
				std::vector < std::string>& strs, 
				const size_t from, 
				const size_t to) const;	
			
			const_iterator begin() const;
			
			const_iterator end() const;
			
		private:
			
			
			
			std::vector < size_t > popLabels;
		
			
			samples sample;
			
			
			
			const boost::shared_ptr <MCTLocusMap> locusMap;
			
			
	};
	
	// does not need to be friend
	std::ostream& operator<< (std::ostream &out, const MCTSampleSequence &seq);

} // end namespace mct

#endif 

